<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on crazy.ark</title>
    <link>https://blog.crazyark.me/tags/algorithm/</link>
    <description>Recent content in Algorithm on crazy.ark</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 13 Apr 2018 01:50:51 +0800</lastBuildDate>
    
	<atom:link href="https://blog.crazyark.me/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>最长回文子串 Manacher 算法 (Longest Palindromic Substring -- Manacher&#39;s Algorithm)</title>
      <link>https://blog.crazyark.me/posts/manachers_algorithm/</link>
      <pubDate>Fri, 13 Apr 2018 01:50:51 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/manachers_algorithm/</guid>
      <description>&lt;p&gt;Emm，这篇其实在 2017 年 9 月就打算写了，到现在才填上，再不填又要忘记了&amp;hellip;&lt;/p&gt;

&lt;p&gt;字符串界的明星回文串，总是有各种稀奇古怪难搞的题目，比如说这道最长回文子串 (Longest Palindromic Substring)，显而易见的算法复杂度是 &lt;code&gt;$O(n^2)$&lt;/code&gt;，而这个 Manacher&amp;rsquo;s Algorithm 则可以在 &lt;code&gt;$O(n)$&lt;/code&gt; 的时间给出答案。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>稀疏表和并行二分查找 (Sparse Table &amp; Parallel Binary Search)</title>
      <link>https://blog.crazyark.me/posts/hourrank23/</link>
      <pubDate>Sun, 10 Sep 2017 01:06:11 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/hourrank23/</guid>
      <description>&lt;p&gt;不刷题不知道自己菜，越刷题越发现自己🙄 —— 记 HourRank23 被虐。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>二叉索引树/树状数组 (Binary Indexed Tree)</title>
      <link>https://blog.crazyark.me/posts/binary_indexed_tree/</link>
      <pubDate>Fri, 08 Sep 2017 22:23:50 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/binary_indexed_tree/</guid>
      <description>&lt;p&gt;Binary Indexed Tree/Fenwick tree 的树构成方式我一直很疑惑，总是似懂非懂。现在终于弄清楚了它的节点的父子关系，记录下来防止忘记。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>线段树 (Segment Tree)</title>
      <link>https://blog.crazyark.me/posts/segment_tree/</link>
      <pubDate>Fri, 08 Sep 2017 12:58:11 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/segment_tree/</guid>
      <description>&lt;p&gt;本篇为WCIPEG上关于SegmentTree的翻译稿，除了删去了几个小节，其余行文结构将完全一致。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;线段树&lt;/strong&gt;是一种非常灵活的数据结构，它可以帮助我们高效地完成对底层数组区间查询或是修改。顾名思义，线段树可以被想象成底层数组区间构成的一棵树，它的基本思想是分治。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>无向带权图图全局最小割 Stoer-Wagner 算法 (Stoer-Wagner Algorithm -- Global Min-Cut in Undirected Weighted Graphs)</title>
      <link>https://blog.crazyark.me/posts/stoer_wagner_al/</link>
      <pubDate>Sat, 05 Aug 2017 22:14:01 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/stoer_wagner_al/</guid>
      <description>&lt;p&gt;最近碰到一道题目，求一个图的全局最小割，可惜图论博主学的不太好，至今只记得一个求s-t最大流/最小割的 ford-fulkerson。想了想总不能做&lt;code&gt;$n^2$&lt;/code&gt;次最大流吧，最终还是求助了维基百科 🤣&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>优化比较次数的排序算法 (Ford Johnson Algorithm)</title>
      <link>https://blog.crazyark.me/posts/ford_johnson_algorithm/</link>
      <pubDate>Fri, 04 Aug 2017 14:15:35 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/ford_johnson_algorithm/</guid>
      <description>&lt;p&gt;偶然发现 AtCoder，上去注册了准备试试，结果卡在practice contest&amp;hellip;&lt;/p&gt;

&lt;p&gt;问题倒是很简单：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;There are N balls labeled with the first N uppercase letters. The balls have pairwise distinct weights.
You are allowed to ask at most Q queries. In each query, you can compare the weights of two balls (see Input/Output section for details).
Sort the balls in the ascending order of their weights.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Constraints&lt;/strong&gt;
(N,Q)=(26,1000), (26,100), or (5,7).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Partial Score&lt;/strong&gt;
There are three testsets. Each testset is worth 100 points.
In testset 1, N=26 and Q=1000.
In testset 2, N=26 and Q=100.
In testset 3, N=5 and Q=7.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过比较排序，一共三种数据，其中 (26, 1000) 的情况用任何比较都能过，但是可能会 TLE，(26, 100) 的用 worst-case &lt;code&gt;$O(nlgn)$&lt;/code&gt; 的 merge sort 能过，唯一难受的是 (5, 7)。这个样例 merge sort 的 worst case 是比较8次。&lt;/p&gt;

&lt;p&gt;我和某网友一样，尝试用 STL 的 sort 来解决，结果发现 WA 了更多 🙄&lt;/p&gt;

&lt;p&gt;You must be kidding!&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>滑动窗口中的最大值 (Sliding Window Maximum / Monotonic Queue)</title>
      <link>https://blog.crazyark.me/posts/monotonic_queue/</link>
      <pubDate>Thu, 03 Aug 2017 15:55:02 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/monotonic_queue/</guid>
      <description>&lt;p&gt;Leetcode 上有一道题叫 Sliding Window Maximum，虽然不是今天刷的，但是解法非常有意思，就记录一下。&lt;/p&gt;

&lt;p&gt;问题描述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.&lt;/p&gt;

&lt;p&gt;For example, Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.&lt;/p&gt;

&lt;p&gt;Therefore, return the max sliding window as [3,3,5,5,6,7].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这道题可以用优先队列、自平衡BST等方法得到一个 O(nlgn) 的解法，但其实这道题有另一种 O(n) 的解法，基本思想是在过程中维持一个单调队列。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>有序矩阵中的第k大数 (Selection in X&#43;Y or Sorted Matrices)</title>
      <link>https://blog.crazyark.me/posts/selection_in_x_plus_y_and_matrices_with_sorted_rows_and_columns/</link>
      <pubDate>Wed, 02 Aug 2017 20:58:55 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/selection_in_x_plus_y_and_matrices_with_sorted_rows_and_columns/</guid>
      <description>&lt;p&gt;今天在刷 leetcode 的时候遇到一道题目 &lt;a href=&#34;https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/&#34;&gt;Kth Smallest Element in a Sorted Matrix&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;首先用一个 Min-Heap 就可以得到 O(klgn) (n为列数)的算法，实现放在最后。&lt;/p&gt;

&lt;p&gt;然而在翻阅览 Discuss 区的时候发现，这玩意居然有 O(n) (n为行、列数) 的算法，来自一篇论文 &lt;a href=&#34;http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf&#34;&gt;Selection in X + Y and Matrices with Sorted Rows and Columns&lt;/a&gt;，同时适用于另一道题 &lt;a href=&#34;https://leetcode.com/problems/find-k-pairs-with-smallest-sums/&#34;&gt;Find k Pairs with Smallest Sums&lt;/a&gt;，在此只做介绍，因为我不认为有人能在面试的时候写的出来&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Boyer-Moore 投票算法 (Boyer-Moore Majority Voting Algorithm)</title>
      <link>https://blog.crazyark.me/posts/majority_voting_al/</link>
      <pubDate>Fri, 28 Jul 2017 21:08:02 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/majority_voting_al/</guid>
      <description>&lt;p&gt;刷leetcode时碰到的问题，本篇仅做简要描述，以及记录思考。&lt;/p&gt;

&lt;p&gt;参考自: &lt;a href=&#34;https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html&#34;&gt;https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html&lt;/a&gt;，一篇写的非常好的博客&lt;/p&gt;

&lt;p&gt;问题描述：考虑你有一个长度为n的&lt;strong&gt;无序&lt;/strong&gt;列表，现在你想知道列表中是否有一个值占据了列表的一半以上 (majority)，如果有的话找出这个数。&lt;/p&gt;

&lt;p&gt;这个问题的一个普遍的应用场景是在容错计算 (fault-tolerant computing) 中，在进行了多次冗余的计算后，输出最后多数计算得到的值。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>