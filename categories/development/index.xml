<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on crazy.ark</title>
    <link>https://blog.crazyark.me/categories/development/</link>
    <description>Recent content in Development on crazy.ark</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 16 Apr 2018 19:51:21 +0800</lastBuildDate>
    
	<atom:link href="https://blog.crazyark.me/categories/development/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Linux IO 多路复用 —— Epoll</title>
      <link>https://blog.crazyark.me/posts/epoll/</link>
      <pubDate>Mon, 16 Apr 2018 19:51:21 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/epoll/</guid>
      <description>&lt;p&gt;Epoll 是 Linux 平台上独有的一组编程接口，用于监听多个文件描述符上的 IO 事件。Epoll 相对于 select/poll 的优势在于即使监听了大量的文件描述符，性能也非常好。Epoll API 支持两种监听方式：edge-triggered (EPOLLET) 和 level_triggered (default)。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>布隆过滤器 (Bloom Filter)</title>
      <link>https://blog.crazyark.me/posts/bloom_filter/</link>
      <pubDate>Mon, 16 Apr 2018 13:02:27 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/bloom_filter/</guid>
      <description>&lt;p&gt;布隆过滤器 (Bloom Filter) 是一个空间高效的&lt;strong&gt;概率&lt;/strong&gt;数据结构，它能够用来测试是否一个元素在一个集合中。布隆过滤器存在着 false positive (返回存在，其实不存在），但是不存在 false negative (返回不存在，其实存在)。集合中的元素越多，false positive 的概率就越高。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>最长回文子串 Manacher 算法 (Longest Palindromic Substring -- Manacher&#39;s Algorithm)</title>
      <link>https://blog.crazyark.me/posts/manachers_algorithm/</link>
      <pubDate>Fri, 13 Apr 2018 01:50:51 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/manachers_algorithm/</guid>
      <description>&lt;p&gt;Emm，这篇其实在 2017 年 9 月就打算写了，到现在才填上，再不填又要忘记了&amp;hellip;&lt;/p&gt;

&lt;p&gt;字符串界的明星回文串，总是有各种稀奇古怪难搞的题目，比如说这道最长回文子串 (Longest Palindromic Substring)，显而易见的算法复杂度是 &lt;code&gt;$O(n^2)$&lt;/code&gt;，而这个 Manacher&amp;rsquo;s Algorithm 则可以在 &lt;code&gt;$O(n)$&lt;/code&gt; 的时间给出答案。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>二部图的最大匹配 (Maximum Matching in Bipartite Graph)</title>
      <link>https://blog.crazyark.me/posts/maximum_matching_in_bipartite_graph/</link>
      <pubDate>Tue, 26 Sep 2017 22:26:08 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/maximum_matching_in_bipartite_graph/</guid>
      <description>&lt;p&gt;上几篇博文主要是关于范围更新和范围查询的几个数据结构，接下去的主题是图论和图算法，希望能够学习和回忆起大部分图算法。&lt;/p&gt;

&lt;p&gt;今天遇到一个问题，可以转化成二部图(bipartite graph)上的完美匹配的存在性问题，我们先来看一下完美匹配的理论，Hall&amp;rsquo;s Marriage theorem；然后介绍两个算法，用于解决完美匹配的超集——最大匹配问题。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>稀疏表和并行二分查找 (Sparse Table &amp; Parallel Binary Search)</title>
      <link>https://blog.crazyark.me/posts/hourrank23/</link>
      <pubDate>Sun, 10 Sep 2017 01:06:11 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/hourrank23/</guid>
      <description>&lt;p&gt;不刷题不知道自己菜，越刷题越发现自己🙄 —— 记 HourRank23 被虐。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>二叉索引树/树状数组 (Binary Indexed Tree)</title>
      <link>https://blog.crazyark.me/posts/binary_indexed_tree/</link>
      <pubDate>Fri, 08 Sep 2017 22:23:50 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/binary_indexed_tree/</guid>
      <description>&lt;p&gt;Binary Indexed Tree/Fenwick tree 的树构成方式我一直很疑惑，总是似懂非懂。现在终于弄清楚了它的节点的父子关系，记录下来防止忘记。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>线段树 (Segment Tree)</title>
      <link>https://blog.crazyark.me/posts/segment_tree/</link>
      <pubDate>Fri, 08 Sep 2017 12:58:11 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/segment_tree/</guid>
      <description>&lt;p&gt;本篇为WCIPEG上关于SegmentTree的翻译稿，除了删去了几个小节，其余行文结构将完全一致。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;线段树&lt;/strong&gt;是一种非常灵活的数据结构，它可以帮助我们高效地完成对底层数组区间查询或是修改。顾名思义，线段树可以被想象成底层数组区间构成的一棵树，它的基本思想是分治。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>神奇的组合数 (AGC019-F Mysterious Combinators)</title>
      <link>https://blog.crazyark.me/posts/agc019_mysterious_combinators/</link>
      <pubDate>Wed, 06 Sep 2017 21:16:06 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/agc019_mysterious_combinators/</guid>
      <description>&lt;p&gt;原题目在 AtCoder Grand Contest 019，F - Yes or No。&lt;/p&gt;

&lt;p&gt;把它改成数学题，题目大意如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;假设你有M+N个问题要回答，每个问题的回答不是Yes就是No。你知道其中有N个Yes，M个No，但是并不知道顺序。你将按顺序一个一个回答问题，并且答完一道题后立刻就能知道这道题的正确答案。
假设你每次回答问题都采取最大化期望正确题目数的方式，请问期望正确题目数是多少？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>最长递增子序列 (Longest Increasing Subsequence)</title>
      <link>https://blog.crazyark.me/posts/longest_increasing_subsequence/</link>
      <pubDate>Fri, 01 Sep 2017 15:41:22 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/longest_increasing_subsequence/</guid>
      <description>&lt;p&gt;最长递增子序列算法，原本以为已经记住了最快的算法，看来是记性太差，今天碰到一道题目又忘记了怎么做 🙄&lt;/p&gt;

&lt;p&gt;三种做法：DP，Sort + LCS，DP + BS，我只记得第一种DP了 &amp;hellip;&lt;/p&gt;

&lt;p&gt;然后咱们顺便把某道题目做了 🤣&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SIGFPE When Doing DivQ</title>
      <link>https://blog.crazyark.me/posts/cpp_sigfpe/</link>
      <pubDate>Sun, 27 Aug 2017 17:38:37 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/cpp_sigfpe/</guid>
      <description>&lt;p&gt;第一次遇到了除0以外的SIGFPE，记录一下。&lt;/p&gt;

&lt;h3 id=&#34;症状&#34;&gt;症状&lt;/h3&gt;

&lt;p&gt;在使用以下函数的时候，假定 a = 1e18, b = 1e18, m = 1e9 + 7 就会触发 SIGFPE。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;long mulmod(long a, long b, long m) {
    long res;
    asm(&amp;quot;mulq %2; divq %3&amp;quot; : &amp;quot;=d&amp;quot;(res), &amp;quot;+a&amp;quot;(a) : &amp;quot;S&amp;quot;(b), &amp;quot;c&amp;quot;(m));
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>整数的超幂 (Project Euler #188 -- The Hyperexponentiation of A Number)</title>
      <link>https://blog.crazyark.me/posts/projecteuler_188/</link>
      <pubDate>Fri, 25 Aug 2017 21:32:26 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/projecteuler_188/</guid>
      <description>&lt;p&gt;接上次的博文，我们来解决大整数分解问题，并最终解决 Project Euler #188。&lt;/p&gt;

&lt;p&gt;回忆一下，问题要求解的是 &lt;code&gt;$a\uparrow\uparrow b \ (\textrm{mod} \ m)$&lt;/code&gt;，其中 &lt;code&gt;$1 \le a, b, m \le 10^{18}$&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;其实这里的整数在整数分解领域并不算太大，之前并没有学习过这类的算法，正好也算是补上了。在这里我使用了 Pollard Rho 算法，其他的算法还有 Fermat Rho 和 Quadratic Sieve 算法。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>多项式哈希及Theu-Morse序列 (Polynomial Hash and Theu-Morse Sequence)</title>
      <link>https://blog.crazyark.me/posts/transaction_certificates/</link>
      <pubDate>Mon, 21 Aug 2017 23:58:42 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/transaction_certificates/</guid>
      <description>&lt;p&gt;前两天刷 Hackerrank 上的 &lt;a href=&#34;https://www.hackerrank.com/contests/gs-codesprint/challenges&#34;&gt;Contest&lt;/a&gt;，给了两天时间，没想到被最后一题卡成🐶，谨记录思考和收获。&lt;/p&gt;

&lt;p&gt;原题目在 &lt;a href=&#34;https://www.hackerrank.com/contests/gs-codesprint/challenges/transaction-certificates&#34;&gt;https://www.hackerrank.com/contests/gs-codesprint/challenges/transaction-certificates&lt;/a&gt; ，就不在此赘述了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>无向带权图图全局最小割 Stoer-Wagner 算法 (Stoer-Wagner Algorithm -- Global Min-Cut in Undirected Weighted Graphs)</title>
      <link>https://blog.crazyark.me/posts/stoer_wagner_al/</link>
      <pubDate>Sat, 05 Aug 2017 22:14:01 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/stoer_wagner_al/</guid>
      <description>&lt;p&gt;最近碰到一道题目，求一个图的全局最小割，可惜图论博主学的不太好，至今只记得一个求s-t最大流/最小割的 ford-fulkerson。想了想总不能做&lt;code&gt;$n^2$&lt;/code&gt;次最大流吧，最终还是求助了维基百科 🤣&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>优化比较次数的排序算法 (Ford Johnson Algorithm)</title>
      <link>https://blog.crazyark.me/posts/ford_johnson_algorithm/</link>
      <pubDate>Fri, 04 Aug 2017 14:15:35 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/ford_johnson_algorithm/</guid>
      <description>&lt;p&gt;偶然发现 AtCoder，上去注册了准备试试，结果卡在practice contest&amp;hellip;&lt;/p&gt;

&lt;p&gt;问题倒是很简单：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;There are N balls labeled with the first N uppercase letters. The balls have pairwise distinct weights.
You are allowed to ask at most Q queries. In each query, you can compare the weights of two balls (see Input/Output section for details).
Sort the balls in the ascending order of their weights.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Constraints&lt;/strong&gt;
(N,Q)=(26,1000), (26,100), or (5,7).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Partial Score&lt;/strong&gt;
There are three testsets. Each testset is worth 100 points.
In testset 1, N=26 and Q=1000.
In testset 2, N=26 and Q=100.
In testset 3, N=5 and Q=7.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过比较排序，一共三种数据，其中 (26, 1000) 的情况用任何比较都能过，但是可能会 TLE，(26, 100) 的用 worst-case &lt;code&gt;$O(nlgn)$&lt;/code&gt; 的 merge sort 能过，唯一难受的是 (5, 7)。这个样例 merge sort 的 worst case 是比较8次。&lt;/p&gt;

&lt;p&gt;我和某网友一样，尝试用 STL 的 sort 来解决，结果发现 WA 了更多 🙄&lt;/p&gt;

&lt;p&gt;You must be kidding!&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>滑动窗口中的最大值 (Sliding Window Maximum / Monotonic Queue)</title>
      <link>https://blog.crazyark.me/posts/monotonic_queue/</link>
      <pubDate>Thu, 03 Aug 2017 15:55:02 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/monotonic_queue/</guid>
      <description>&lt;p&gt;Leetcode 上有一道题叫 Sliding Window Maximum，虽然不是今天刷的，但是解法非常有意思，就记录一下。&lt;/p&gt;

&lt;p&gt;问题描述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.&lt;/p&gt;

&lt;p&gt;For example, Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.&lt;/p&gt;

&lt;p&gt;Therefore, return the max sliding window as [3,3,5,5,6,7].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这道题可以用优先队列、自平衡BST等方法得到一个 O(nlgn) 的解法，但其实这道题有另一种 O(n) 的解法，基本思想是在过程中维持一个单调队列。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>有序矩阵中的第k大数 (Selection in X&#43;Y or Sorted Matrices)</title>
      <link>https://blog.crazyark.me/posts/selection_in_x_plus_y_and_matrices_with_sorted_rows_and_columns/</link>
      <pubDate>Wed, 02 Aug 2017 20:58:55 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/selection_in_x_plus_y_and_matrices_with_sorted_rows_and_columns/</guid>
      <description>&lt;p&gt;今天在刷 leetcode 的时候遇到一道题目 &lt;a href=&#34;https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/&#34;&gt;Kth Smallest Element in a Sorted Matrix&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;首先用一个 Min-Heap 就可以得到 O(klgn) (n为列数)的算法，实现放在最后。&lt;/p&gt;

&lt;p&gt;然而在翻阅览 Discuss 区的时候发现，这玩意居然有 O(n) (n为行、列数) 的算法，来自一篇论文 &lt;a href=&#34;http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf&#34;&gt;Selection in X + Y and Matrices with Sorted Rows and Columns&lt;/a&gt;，同时适用于另一道题 &lt;a href=&#34;https://leetcode.com/problems/find-k-pairs-with-smallest-sums/&#34;&gt;Find k Pairs with Smallest Sums&lt;/a&gt;，在此只做介绍，因为我不认为有人能在面试的时候写的出来&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dynamic Proxy in Java</title>
      <link>https://blog.crazyark.me/posts/dynamic_proxy/</link>
      <pubDate>Sat, 29 Jul 2017 22:44:24 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/dynamic_proxy/</guid>
      <description>&lt;p&gt;虽然在一年前就知道了 Proxy 模式，但是基本没有尝试使用过，仅在框架里看到一些例子。昨天翻阅《大型网站系统与Java中间件实践》时，偶然发现了 Proxy 模式在 Java 中的应用 —— 动态代理，遂记录下来，顺便复习一下 Proxy 模式。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Boyer-Moore 投票算法 (Boyer-Moore Majority Voting Algorithm)</title>
      <link>https://blog.crazyark.me/posts/majority_voting_al/</link>
      <pubDate>Fri, 28 Jul 2017 21:08:02 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/majority_voting_al/</guid>
      <description>&lt;p&gt;刷leetcode时碰到的问题，本篇仅做简要描述，以及记录思考。&lt;/p&gt;

&lt;p&gt;参考自: &lt;a href=&#34;https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html&#34;&gt;https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html&lt;/a&gt;，一篇写的非常好的博客&lt;/p&gt;

&lt;p&gt;问题描述：考虑你有一个长度为n的&lt;strong&gt;无序&lt;/strong&gt;列表，现在你想知道列表中是否有一个值占据了列表的一半以上 (majority)，如果有的话找出这个数。&lt;/p&gt;

&lt;p&gt;这个问题的一个普遍的应用场景是在容错计算 (fault-tolerant computing) 中，在进行了多次冗余的计算后，输出最后多数计算得到的值。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2017 Alibaba Middleware 24h Final (Just for Fun 😀)</title>
      <link>https://blog.crazyark.me/posts/topkn/</link>
      <pubDate>Wed, 26 Jul 2017 16:59:26 +0800</pubDate>
      
      <guid>https://blog.crazyark.me/posts/topkn/</guid>
      <description>&lt;p&gt;今年阿里中间件比赛的时候不巧博主心情不好，外加要准备期末考试，并没有参加，非常遗憾。不过好在好基友 &lt;a href=&#34;https://ericfu.me&#34;&gt;Eric Fu&lt;/a&gt; 参加并获得了冠军！今年的主题是分布式数据库，如果想了解详情及复赛的解题思路请读者前往 Eric 的博客。&lt;/p&gt;

&lt;p&gt;博主没有参加甚是遗憾，外加看到题目手痒难耐，遂问基友讨了最后的24h极客赛来玩一玩。&lt;/p&gt;

&lt;h2 id=&#34;24h-topkn&#34;&gt;24h TOPKN&lt;/h2&gt;

&lt;p&gt;题目是分布式数据库上的分页排序，对应的SQL执行为 order by id limit k，n；主要的技术挑战为&amp;rdquo;分布式&amp;rdquo;的策略，赛题中使用多个文件模拟多个数据分片。&lt;/p&gt;

&lt;p&gt;简称 top(k, n)。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>