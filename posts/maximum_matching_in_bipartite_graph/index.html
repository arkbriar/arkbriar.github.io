<!DOCTYPE html>
<html>

<head>
  <title> 二部图的最大匹配 (Maximum Matching in Bipartite Graph) &middot; crazy.ark </title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.87.0" />


<link rel="stylesheet" href="https://blog.crazyark.xyz/css/vec.css">
<link rel="stylesheet" href="https://blog.crazyark.xyz/css/github.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/favicon.ico">


<link href="" rel="alternate" type="application/rss+xml" title="crazy.ark" />

</head>

<body>
  <header>
  <nav>
    <ul>
      
      
      <li class="pull-left ">
        <a href="https://blog.crazyark.xyz/">/home/crazy.ark</a>
      </li>
      
      
      <li class="pull-left ">
        <a href="/about">~/about</a>
      </li>
      
      
      <li class="pull-left ">
        <a href="https://ericfu.me">~/external/coding husky</a>
      </li>
      
      
      <li class="pull-left current">
        <a href="/posts">~/posts</a>
      </li>
      
  
      <li class="pull-right"><a href=""><i class="fas fa-rss"></i></a></li>
    </ul>
  </nav>
</header>

  <div class="content toc">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#halls-marriage-theorem">Hall&rsquo;s Marriage Theorem</a></li>
        <li><a href="#hungarian-algorithm">Hungarian Algorithm</a></li>
        <li><a href="#hopcroft-karp-algorithm">Hopcroft-Karp Algorithm</a></li>
        <li><a href="#a-problem">A Problem</a></li>
        <li><a href="#references">References</a></li>
        <li><a href="#appendix">Appendix</a></li>
      </ul>
    </li>
  </ul>
</nav>
    
    <section class="post">
      <h1 class="post-title"><a href="https://blog.crazyark.xyz/posts/maximum_matching_in_bipartite_graph/">二部图的最大匹配 (Maximum Matching in Bipartite Graph)</a></h1>
      <span class="post-date">Sep 26, 2017 </span>
      <div class="post-content">
        <p>上几篇博文主要是关于范围更新和范围查询的几个数据结构，接下去的主题是图论和图算法，希望能够学习和回忆起大部分图算法。</p>
<p>今天遇到一个问题，可以转化成二部图(bipartite graph)上的完美匹配的存在性问题，我们先来看一下完美匹配的理论，Hall&rsquo;s Marriage theorem；然后介绍两个算法，用于解决完美匹配的超集——最大匹配问题。</p>
<h3 id="halls-marriage-theorem">Hall&rsquo;s Marriage Theorem</h3>
<p>令 <code>$G$</code> 表示一个二部图，左部和右部分别为 <code>$X$</code> 和 <code>$Y$</code>。令 <code>$W \subset X$</code>, <code>$N_G(W)$</code> 为 <code>$W$</code> 在 <code>$Y$</code> 中的相邻点的集合。</p>
<p>那么如果存在一个匹配方式覆盖整个 <code>$X$</code> 当且仅当</p>
<p><code>$\forall W \subset X, |W| \le |N_G(W)|$</code>，也就是说每个 <code>$X$</code> 的子集都有足够的邻居做匹配。</p>
<h4 id="deduction-1-1">Deduction 1 [1]</h4>
<p>加入一个二部图 <code>$G(X + Y, E)$</code>，<code>$|X| = |Y|$</code>，<code>$G$</code> 是连通图，且每个 <code>$X$</code> 中的点的度数都不相同，那么 <code>$G$</code> 上一定存在完美匹配。</p>
<p>证明：</p>
<p>首先，因为 <code>$G$</code> 是连通图，所以 <code>$\forall u \in X, deg(u) &gt;= 1$</code>。
那么 <code>$\forall W \subset X$</code>， <code>$\max\limits_{u \in W}\{deg(u)\} \ge |S|$</code>，满足 Hall&rsquo;s Marriage Theorem，得证。</p>
<h3 id="hungarian-algorithm">Hungarian Algorithm</h3>
<p>事实上，我对照着找了半天，并没有找到一个叫匈牙利算法 (Hungarian Algorithm) 的用于二部图最大匹配的算法，唯一找到的 Hungarian Algorithm 是用于任务分配问题 (Assignment Problem)，也就是带权二部图的最大匹配。</p>
<p>由于最大匹配问题与最大流问题能够很容易的互相转换，所以同时我也找到了许多思想类似甚至一致的算法，如 Ford-Fulkerson Algorihtm，Edmonds-Karp Algorithm 等。</p>
<p>至于匈牙利算法这个名字是哪本书上提出的，我已经记不太清了 &hellip; 应该是某本学习过的图论书，在此主要讲一下它的具体思想和证明。</p>
<h4 id="alternating-path--augmenting-path">Alternating Path &amp; Augmenting Path</h4>
<p>假设我们有一个二部图 <code>$G(U + V, E)$</code>，现在有一个匹配 <code>$M \subset E$</code>，此时如果 <code>$M$</code> 中的边上的点集中不存在一个点，我们就说该点是未匹配的，未匹配边的定义类似。</p>
<p>交替路径 (alternating path)：从一个未匹配点出发，经过未匹配边、匹配边、未匹配边&hellip;这样交替的路径叫做交替路径。
增广路径 (augmenting path)：从 <code>$U$</code> 中一个未匹配点出发，到达 <code>$V$</code> 中一个未匹配点的<strong>交替路</strong>叫做增广路径。</p>
<p>显然，由增广路径的定义，可以知道增广路径上未匹配边比匹配边要多一条，并且将这条路径上所有未匹配边改为匹配边，匹配边改为未匹配边，则修改后的匹配 <code>$M'$</code> 比原来大1。</p>
<h4 id="theorem-of-augmenting-path">Theorem of Augmenting Path</h4>
<p>一个匹配 <code>$M$</code> 是最大匹配当且仅当那么在图 <code>$G$</code> 上不存在增广路径。</p>
<p>证明如下：</p>
<p>假设存在一条增广路径，<code>$M$</code> 显然不是最大的。所以我们只需要证明当不存在增广路径时，<code>$M$</code> 是最大的。</p>
<p>假设存在一个匹配 <code>$M$</code>，不存在增广路径并且 <code>$M$</code> 不是最大匹配，我们令 <code>$M^*$</code> 为 <code>$G$</code> 上的一个最大匹配，显然 <code>$|M^*| &gt; |M|$</code>。</p>
<p>所以同时有 <code>$|M^* - M| &gt; |M - M^*|$</code>。</p>
<p>考察所有在 <code>$M^*$</code> 和 <code>$M$</code> 对称差 (<code>$M^* \cup M - M^* \cap M$</code>) 中的边，令 <code>$G'$</code> 是由点 <code>$U + V$</code> 和上述边构成的图。</p>
<p>因为 <code>$G'$</code> 中的边是来自两个匹配，所以 <code>$G'$</code> 上任意一个点最多与两条边相连。</p>
<p>因此，对于 <code>$G'$</code> 上的任意联通分支，只可能是一条路或者一个环，并且边的数目是偶数，并且路或者环上对于 <code>$M^* - M$</code> 或者 <code>$M - M^*$</code> 一定构成交替路。</p>
<p>因为 <code>$|M^* - M| &gt; |M - M^*|$</code> 并且环都是偶数条边，所以一定有一条路，它的边，它的起点和终点都在 <code>$M^* - M$</code> 中，且 <code>$M^* - M$</code> 和 <code>$M - M^*$</code> 交替构成，显然这条路对于 <code>$M$</code> 构成增广路径，矛盾！</p>
<p>得证。</p>
<h4 id="pseudocode">Pseudocode</h4>
<p>匈牙利算法有两种实现，分别基于 DFS 和 BFS，时间复杂度都是 <code>$\mathcal{O}(|V||E|)$</code>。</p>
<p>下面是 BFS 版本的伪代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">Algorithm MaximumBigartiteMatching(G)
    initialize set M of edges // can be the empty set
    initialize queue Q with all the free vertices in V
    while not Empty(Q) do
        w ← Front(Q)
        if w ε V then
            for every vertex u adjacent to w do // u must be in U
                if u is free then // augment
                    M ← M union (w, u)
                    v ← w
                    while v is labeled do // follow the augmenting path
                        u ← label of v
                        M ← M - (v, u)  // (v, u) was in previous M
                        v ← label of u
                        M ← M union (v, u) // add the edge to the path
                    // start over
                    remove all vertex labels
                    reinitialize Q with all the free vertices in V
                    break // exit the for loop
                else // u is matched
                    if (w, u) not in M and u is unlabeled then
                    label u with w // represents an edge in E-M
                    Enqueue(Q, u)
                    // only way for a U vertex to enter the queue
         
        else // w ε U and therefore is matched with v
            v  ←  w&#39;s mate // (w, v) is in M
            label v with w // represents in M
            Enqueue(Q, v) // only way for a mated v to enter Q
</code></pre></div><p>相比于 BFS，DFS 版本的匈牙利算法更容易实现，它 C++ 代码可以参考附录。</p>
<h3 id="hopcroft-karp-algorithm">Hopcroft-Karp Algorithm</h3>
<p>Hopcroft-Karp 算法是一个专用于解二部图最大匹配问题的算法，它最差情况的时间复杂度为 <code>$\mathcal{O}(|E|\sqrt{|V|})$</code>，最差情况下的空间开销为 <code>$\mathcal{O}(|V|)$</code>。</p>
<p>Hopcroft-Karp 算法是在1973年由 Hohn Hopcroft 和 Richard Karp 两位计算机学者发现的。</p>
<p>和匈牙利算法一样，Hopcroft-Karp 算法同样是不断地通过寻找增广路径，来增大部分匹配。不同的是，匈牙利算法每次只找到一条增广路径，而该算法则每次找增广路径的一个最大集合，从而我们只需要进行 <code>$\mathcal{O}(\sqrt{|V|})$</code> 次迭代。</p>
<p>Hopcroft-Karp 算法循环以下两个阶段：</p>
<ol>
<li>用 BFS 寻找下一个长度的增广路径，并且能遍历该长度下所有增广路径 (也就是上面所说的最大集合)。</li>
<li>如果存在更长的增广路径，对每个可能的起点 u，用 DFS 寻找并记录增广路径</li>
</ol>
<p>每一次循环，BFS 所找到的最短增广路径的长度至少增加1，所以在 <code>$\sqrt{|V|}$</code> 次循环以后，能找到的最短增广路径长度至少为 <code>$\sqrt{|V|}$</code>。假设当前的部分匹配集合为 <code>$M$</code> (边集)，<code>$M$</code> 和最大匹配的对称差组成了一组点不相交的增广路径和交替环。如果这个集合内所有的路径的长度都至少为 <code>$\sqrt{|V|}$</code>，那么最多只有 <code>$\sqrt{|V|}$</code> 条路径，那么最大匹配的大小与 <code>$|M|$</code> 最多为 <code>$\sqrt{|V|}$</code>。而每次循环至少将匹配大小增加1，所以直到算法结束最多还有 <code>$\sqrt{|V|}$</code> 次循环。</p>
<p>每次循环中，BFS 最多遍历图中每条边，DFS 也是最多遍历每条边，所以每一轮循环的时间复杂度为 <code>$\mathcal{O}({|E|})$</code>，总时间复杂度为 <code>$\mathcal{O}({|E|\sqrt{|V|}})$</code>。</p>
<h4 id="pseudocode-1">Pseudocode</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">/* 
 G = U ∪ V ∪ {NIL}
 where U and V are partition of graph and NIL is a special null vertex
*/
  
function BFS ()
    for each u in U
        if Pair_U[u] == NIL
            Dist[u] = 0
            Enqueue(Q,u)
        else
            Dist[u] = ∞
    Dist[NIL] = ∞
    while Empty(Q) == false
        u = Dequeue(Q)
        if Dist[u] &lt; Dist[NIL] 
            for each v in Adj[u]
                if Dist[ Pair_V[v] ] == ∞
                    Dist[ Pair_V[v] ] = Dist[u] + 1
                    Enqueue(Q,Pair_V[v])
    return Dist[NIL] != ∞

function DFS (u)
    if u != NIL
        for each v in Adj[u]
            if Dist[ Pair_V[v] ] == Dist[u] + 1
                if DFS(Pair_V[v]) == true
                    Pair_V[v] = u
                    Pair_U[u] = v
                    return true
        Dist[u] = ∞
        return false
    return true

function Hopcroft-Karp
    for each u in U
        Pair_U[u] = NIL
    for each v in V
        Pair_V[v] = NIL
    matching = 0
    while BFS() == true
        for each u in U
            if Pair_U[u] == NIL
                if DFS(u) == true
                    matching = matching + 1
    return matching
</code></pre></div><h3 id="a-problem">A Problem</h3>
<p>一个可以转换成做完美匹配的题目，题目大意：</p>
<blockquote>
<p>二维平面上一共 n 个人和 n 个防空洞，现在你需要将 n 个人分配到防空洞中，使得每个防空洞仅容纳一个人，并且所有人进入防空洞的时间最短，即最晚进入防空洞的人的时间最短。一个人从 (X, Y) 移动到 (X1, Y1) 所需时间为 |X - X1| + |Y - Y1|。
1 &lt;= n &lt;= 100</p>
</blockquote>
<p>这道题直接做我没有想到什么好办法，但是观察到可能解一定为某个人移动到某个防空洞的时间，所以我们将所有人移动到所有防空洞的时间全部计算出来并排序。</p>
<p>对于某个人移动到某个防空洞，假设耗时为 T，那么所有耗时小于等于 T 的移动操作是可行的。我们建立一张二部图，左边是人的集合，右边是防空洞的集合，对于所有可行操作，我们在二部图上添加一条对应的边。那么如果此时存在一种分配方式满足上述条件，它在图上一定是一个完美匹配，而目标就是找到这样最小的一个T。</p>
<p>对于我们的二部图，最差情况为完全二部图，对于匈牙利算法判定完美匹配的时间复杂度为 <code>$\mathcal{O}(n^3)$</code>，Hopcroft-Karp 算法为 <code>$\mathcal{O}(n^2\sqrt{n})$</code>，所以判定复杂度还是比较高的。</p>
<p>假如我们一条一条添加，也就是按照耗时顺序添加，那么最坏情况一共要判定 <code>$n^2$</code> 次，这太高了，这里数据比较小还可以，但是万一n大到1000就难说了。</p>
<p>还记得之前我们提过的减小判定次数的方式嘛？对，二分查找，一共判定 <code>$2\log n$</code> 次。</p>
<p>在这里，我们同时也存在模拟复杂度，这里模拟为构造对应的二部图，每次构造的最坏时间复杂度为 <code>$n^2$</code>，所以总计时间复杂度为 <code>$\mathcal{O}(n^3\log n)$</code> 或者 <code>$\mathcal{O}(n^2\sqrt{n}\log n)$</code>。</p>
<p>代码实现在附录中。</p>
<h3 id="references">References</h3>
<p>[1] <a href="https://en.wikipedia.org/wiki/Hall%27s_marriage_theorem">https://en.wikipedia.org/wiki/Hall%27s_marriage_theorem</a></p>
<p>[2] <a href="https://math.stackexchange.com/questions/1204270/bipartite-graph-has-perfect-matching">https://math.stackexchange.com/questions/1204270/bipartite-graph-has-perfect-matching</a></p>
<p>[3] <a href="https://en.wikipedia.org/wiki/Matching_(graph_theory)">https://en.wikipedia.org/wiki/Matching_(graph_theory)</a></p>
<p>[4] <a href="https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm">https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm</a></p>
<p>[5] <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/maximum-flow-augmenting-path-algorithms-comparison/">https://www.topcoder.com/community/data-science/data-science-tutorials/maximum-flow-augmenting-path-algorithms-comparison/</a></p>
<p>[6] <a href="http://www.csl.mtu.edu/cs4321/www/Lectures/Lecture%2022%20-%20Maximum%20Matching%20in%20Bipartite%20Graph.htm">http://www.csl.mtu.edu/cs4321/www/Lectures/Lecture%2022%20-%20Maximum%20Matching%20in%20Bipartite%20Graph.htm</a></p>
<h3 id="appendix">Appendix</h3>
<h4 id="air-defense-exercise">Air Defense Exercise</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#579">#include</span> <span style="color:#579">&lt;cstdio&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;cstdlib&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;iostream&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;algorithm&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;vector&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;string&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;stack&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;cmath&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;deque&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;queue&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;map&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;bitset&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;set&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;list&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;unordered_map&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;unordered_set&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;sstream&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;numeric&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;climits&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;utility&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;iomanip&gt;</span><span style="color:#579">
</span><span style="color:#579">#include</span> <span style="color:#579">&lt;cassert&gt;</span><span style="color:#579">
</span><span style="color:#579"></span>
<span style="color:#080;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#080;font-weight:bold">using</span> ll <span style="color:#333">=</span> <span style="color:#339;font-weight:bold">long</span> <span style="color:#339;font-weight:bold">long</span>;
<span style="color:#080;font-weight:bold">using</span> ii <span style="color:#333">=</span> pair<span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">int</span>, <span style="color:#339;font-weight:bold">int</span><span style="color:#333">&gt;</span>;
<span style="color:#080;font-weight:bold">using</span> iii <span style="color:#333">=</span> pair<span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">int</span>, ii<span style="color:#333">&gt;</span>;
<span style="color:#080;font-weight:bold">template</span> <span style="color:#333">&lt;</span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">T</span><span style="color:#333">&gt;</span>
<span style="color:#080;font-weight:bold">using</span> vv <span style="color:#333">=</span> vector<span style="color:#333">&lt;</span>vector<span style="color:#333">&lt;</span>T<span style="color:#333">&gt;&gt;</span>;

<span style="color:#579">#define rep(i, b) for (int i = 0; i &lt; int(b); ++i)
</span><span style="color:#579">#define reps(i, a, b) for (int i = int(a); i &lt; int(b); ++i)
</span><span style="color:#579">#define rrep(i, b) for (int i = int(b) - 1; i &gt;= 0; --i)
</span><span style="color:#579">#define rreps(i, a, b) for (int i = int(b) - 1; i &gt;= a; --i)
</span><span style="color:#579">#define repe(i, b) for (int i = 0; i &lt;= int(b); ++i)
</span><span style="color:#579">#define repse(i, a, b) for (int i = int(a); i &lt;= int(b); ++i)
</span><span style="color:#579">#define rrepe(i, b) for (int i = int(b); i &gt;= 0; --i)
</span><span style="color:#579">#define rrepse(i, a, b) for (int i = int(b); i &gt;= int(a); --i)
</span><span style="color:#579"></span>
<span style="color:#579">#define all(a) a.begin(), a.end()
</span><span style="color:#579">#define rall(a) a.rbegin(), a.rend()
</span><span style="color:#579">#define sz(a) int(a.size())
</span><span style="color:#579">#define mp(a, b) make_pair(a, b)
</span><span style="color:#579"></span>
<span style="color:#579">#define inf (INT_MAX / 2)
</span><span style="color:#579">#define infl (LONG_MAX / 2)
</span><span style="color:#579">#define infll (LLONG_MAX / 2)
</span><span style="color:#579"></span>
<span style="color:#579">#define X first
</span><span style="color:#579">#define Y second
</span><span style="color:#579">#define pb push_back
</span><span style="color:#579">#define eb emplace_back
</span><span style="color:#579"></span>
<span style="color:#888">// tools for pair&lt;int, int&gt; &amp; graph
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">template</span> <span style="color:#333">&lt;</span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">T</span>, size_t M, size_t N<span style="color:#333">&gt;</span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">graph_delegate_t</span> {
    T (<span style="color:#333">&amp;</span>f)[M][N];

<span style="color:#080;font-weight:bold">public</span><span style="color:#333">:</span>
    graph_delegate_t(T (<span style="color:#333">&amp;</span>f)[M][N]) <span style="color:#333">:</span> f(f) {}
    T<span style="color:#333">&amp;</span> <span style="color:#080;font-weight:bold">operator</span>[](<span style="color:#080;font-weight:bold">const</span> ii<span style="color:#333">&amp;</span> s) { <span style="color:#080;font-weight:bold">return</span> f[s.first][s.second]; }
    <span style="color:#080;font-weight:bold">const</span> T<span style="color:#333">&amp;</span> <span style="color:#080;font-weight:bold">operator</span>[](<span style="color:#080;font-weight:bold">const</span> ii<span style="color:#333">&amp;</span> s) <span style="color:#080;font-weight:bold">const</span> { <span style="color:#080;font-weight:bold">return</span> f[s.first][s.second]; }
};
ii <span style="color:#080;font-weight:bold">operator</span><span style="color:#333">+</span>(<span style="color:#080;font-weight:bold">const</span> ii<span style="color:#333">&amp;</span> lhs, <span style="color:#080;font-weight:bold">const</span> ii<span style="color:#333">&amp;</span> rhs) {
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#06b;font-weight:bold">mp</span>(lhs.first <span style="color:#333">+</span> rhs.first, lhs.second <span style="color:#333">+</span> rhs.second);
}

<span style="color:#888">// clang-format off
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">template</span> <span style="color:#333">&lt;</span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">S</span>, <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">T</span><span style="color:#333">&gt;</span> ostream<span style="color:#333">&amp;</span> <span style="color:#080;font-weight:bold">operator</span><span style="color:#333">&lt;&lt;</span>(ostream<span style="color:#333">&amp;</span> os, <span style="color:#080;font-weight:bold">const</span> pair<span style="color:#333">&lt;</span>S, T<span style="color:#333">&gt;&amp;</span> t) { <span style="color:#080;font-weight:bold">return</span> os <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;(&#34;</span> <span style="color:#333">&lt;&lt;</span> t.first <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;,&#34;</span> <span style="color:#333">&lt;&lt;</span> t.second <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;)&#34;</span>; }
<span style="color:#080;font-weight:bold">template</span> <span style="color:#333">&lt;</span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">T</span><span style="color:#333">&gt;</span> ostream<span style="color:#333">&amp;</span> <span style="color:#080;font-weight:bold">operator</span><span style="color:#333">&lt;&lt;</span>(ostream<span style="color:#333">&amp;</span> os, <span style="color:#080;font-weight:bold">const</span> vector<span style="color:#333">&lt;</span>T<span style="color:#333">&gt;&amp;</span> t) { os <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;{&#34;</span>; rep(i, t.size() <span style="color:#333">-</span> <span style="color:#00d;font-weight:bold">1</span>) { os <span style="color:#333">&lt;&lt;</span> t[i] <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;,&#34;</span>; } <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>t.empty()) os <span style="color:#333">&lt;&lt;</span> t.back(); os <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;}&#34;</span>; <span style="color:#080;font-weight:bold">return</span> os; }
vector<span style="color:#333">&lt;</span>string<span style="color:#333">&gt;</span> __macro_split(<span style="color:#080;font-weight:bold">const</span> string<span style="color:#333">&amp;</span> s) { vector<span style="color:#333">&lt;</span>string<span style="color:#333">&gt;</span> v; <span style="color:#339;font-weight:bold">int</span> d <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>, f <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>; string t; <span style="color:#080;font-weight:bold">for</span> (<span style="color:#339;font-weight:bold">char</span> <span style="color:#970;font-weight:bold">c</span> : s) { <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>d <span style="color:#333">&amp;&amp;</span> c <span style="color:#333">==</span> <span style="color:#04d;background-color:#fff0f0">&#39;,&#39;</span>) v.pb(t), t <span style="color:#333">=</span> <span style="background-color:#fff0f0">&#34;&#34;</span>; <span style="color:#080;font-weight:bold">else</span> t <span style="color:#333">+=</span> c; <span style="color:#080;font-weight:bold">if</span> (c <span style="color:#333">==</span> <span style="color:#04d;background-color:#fff0f0">&#39;\&#34;&#39;</span> <span style="color:#333">||</span> c <span style="color:#333">==</span> <span style="color:#04d;background-color:#fff0f0">&#39;\&#39;&#39;</span>) f <span style="color:#333">^=</span> <span style="color:#00d;font-weight:bold">1</span>; <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>f <span style="color:#333">&amp;&amp;</span> c <span style="color:#333">==</span> <span style="color:#04d;background-color:#fff0f0">&#39;(&#39;</span>) <span style="color:#333">++</span>d; <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">!</span>f <span style="color:#333">&amp;&amp;</span> c <span style="color:#333">==</span> <span style="color:#04d;background-color:#fff0f0">&#39;)&#39;</span>) <span style="color:#333">--</span>d; } v.pb(t); <span style="color:#080;font-weight:bold">return</span> v; }
<span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">__args_output</span>(vector<span style="color:#333">&lt;</span>string<span style="color:#333">&gt;::</span>iterator, vector<span style="color:#333">&lt;</span>string<span style="color:#333">&gt;::</span>iterator) { cerr <span style="color:#333">&lt;&lt;</span> endl; }
<span style="color:#080;font-weight:bold">template</span> <span style="color:#333">&lt;</span><span style="color:#080;font-weight:bold">typename</span> T, <span style="color:#080;font-weight:bold">typename</span>... Args<span style="color:#333">&gt;</span>
<span style="color:#339;font-weight:bold">void</span> __args_output(vector<span style="color:#333">&lt;</span>string<span style="color:#333">&gt;::</span>iterator it, vector<span style="color:#333">&lt;</span>string<span style="color:#333">&gt;::</span>iterator end, T a, Args... args) { cerr <span style="color:#333">&lt;&lt;</span> it<span style="color:#333">-&gt;</span>substr((<span style="color:#333">*</span>it)[<span style="color:#00d;font-weight:bold">0</span>] <span style="color:#333">==</span> <span style="color:#04d;background-color:#fff0f0">&#39; &#39;</span>, it<span style="color:#333">-&gt;</span>length()) <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34; = &#34;</span> <span style="color:#333">&lt;&lt;</span> a; <span style="color:#080;font-weight:bold">if</span> (<span style="color:#333">++</span>it <span style="color:#333">!=</span> end) { cerr <span style="color:#333">&lt;&lt;</span> <span style="background-color:#fff0f0">&#34;, &#34;</span>; } __args_output(it, end, args...); }
<span style="color:#579">#define out(args...) { vector&lt;string&gt; __args = __macro_split(#args); __args_output(__args.begin(), __args.end(), args); }
</span><span style="color:#579"></span><span style="color:#888">// clang-format on
</span><span style="color:#888"></span>
<span style="color:#080;font-weight:bold">const</span> <span style="color:#339;font-weight:bold">int</span> MAX_N <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">100</span>;
<span style="color:#339;font-weight:bold">int</span> n;
ii p[MAX_N], h[MAX_N];
iii d[MAX_N <span style="color:#333">*</span> MAX_N];

vector<span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">int</span><span style="color:#333">&gt;</span> edges[MAX_N];
<span style="color:#339;font-weight:bold">int</span> match[MAX_N];
<span style="color:#339;font-weight:bold">bool</span> visited[MAX_N];

<span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">link</span>(<span style="color:#339;font-weight:bold">int</span> u, <span style="color:#339;font-weight:bold">int</span> v) { edges[u].push_back(v); }

<span style="color:#339;font-weight:bold">bool</span> <span style="color:#06b;font-weight:bold">dfs</span>(<span style="color:#339;font-weight:bold">int</span> u) {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#080;font-weight:bold">auto</span> <span style="color:#970;font-weight:bold">v</span> : edges[u]) {
        <span style="color:#080;font-weight:bold">if</span> (visited[v]) <span style="color:#080;font-weight:bold">continue</span>;
        visited[v] <span style="color:#333">=</span> <span style="color:#007020">true</span>;
        <span style="color:#080;font-weight:bold">if</span> (match[v] <span style="color:#333">==</span> <span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">||</span> dfs(match[v])) {
            match[v] <span style="color:#333">=</span> u;
            <span style="color:#080;font-weight:bold">return</span> <span style="color:#007020">true</span>;
        }
    }
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#007020">false</span>;
}

<span style="color:#339;font-weight:bold">bool</span> <span style="color:#06b;font-weight:bold">hungarian</span>() {
    <span style="color:#339;font-weight:bold">int</span> m <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>;
    fill_n(match, n, <span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span>);
    rep(i, n) {
        fill_n(visited, n, <span style="color:#007020">false</span>);
        <span style="color:#080;font-weight:bold">if</span> (dfs(i)) <span style="color:#333">++</span>m;
    }
    <span style="color:#080;font-weight:bold">return</span> m <span style="color:#333">==</span> n;
}

<span style="color:#339;font-weight:bold">int</span> match_u[MAX_N], match_v[MAX_N];
<span style="color:#339;font-weight:bold">int</span> dist[MAX_N];
<span style="color:#339;font-weight:bold">int</span> NIL <span style="color:#333">=</span> MAX_N;

<span style="color:#339;font-weight:bold">bool</span> <span style="color:#06b;font-weight:bold">bfs</span>() {
    queue<span style="color:#333">&lt;</span><span style="color:#339;font-weight:bold">int</span><span style="color:#333">&gt;</span> q;
    rep(u, n) {
        <span style="color:#080;font-weight:bold">if</span> (match_u[u] <span style="color:#333">==</span> NIL) {
            dist[u] <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>;
            q.push(u);
        } <span style="color:#080;font-weight:bold">else</span> {
            dist[u] <span style="color:#333">=</span> inf;
        }
    }

    dist[NIL] <span style="color:#333">=</span> inf;
    <span style="color:#080;font-weight:bold">while</span> (<span style="color:#333">!</span>q.empty()) {
        <span style="color:#080;font-weight:bold">auto</span> u <span style="color:#333">=</span> q.front();
        q.pop();
        <span style="color:#080;font-weight:bold">for</span> (<span style="color:#080;font-weight:bold">auto</span> <span style="color:#970;font-weight:bold">v</span> : edges[u]) {
            <span style="color:#080;font-weight:bold">if</span> (dist[match_v[v]] <span style="color:#333">==</span> inf) {
                dist[match_v[v]] <span style="color:#333">=</span> dist[u] <span style="color:#333">+</span> <span style="color:#00d;font-weight:bold">1</span>;
                <span style="color:#080;font-weight:bold">if</span> (match_v[v] <span style="color:#333">!=</span> NIL) q.push(match_v[v]);
            }
        }
    }
    <span style="color:#080;font-weight:bold">return</span> dist[NIL] <span style="color:#333">!=</span> inf;
}

<span style="color:#339;font-weight:bold">bool</span> <span style="color:#06b;font-weight:bold">dfs_h</span>(<span style="color:#339;font-weight:bold">int</span> u) {
    <span style="color:#080;font-weight:bold">if</span> (u <span style="color:#333">==</span> NIL) <span style="color:#080;font-weight:bold">return</span> <span style="color:#007020">true</span>;
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#080;font-weight:bold">auto</span> <span style="color:#970;font-weight:bold">v</span> : edges[u]) {
        <span style="color:#080;font-weight:bold">if</span> (dist[match_v[v]] <span style="color:#333">==</span> dist[u] <span style="color:#333">+</span> <span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">&amp;&amp;</span> dfs_h(match_v[v])) {
            match_u[u] <span style="color:#333">=</span> v;
            match_v[v] <span style="color:#333">=</span> u;
            <span style="color:#080;font-weight:bold">return</span> <span style="color:#007020">true</span>;
        }
    }
    dist[u] <span style="color:#333">=</span> inf;
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#007020">false</span>;
}

<span style="color:#339;font-weight:bold">bool</span> <span style="color:#06b;font-weight:bold">hopcraft_karp</span>() {
    <span style="color:#339;font-weight:bold">int</span> m <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>;
    fill_n(match_u, n, NIL);
    fill_n(match_v, n, NIL);
    <span style="color:#080;font-weight:bold">while</span> (bfs()) {
        rep(u, n) {
            <span style="color:#080;font-weight:bold">if</span> (match_u[u] <span style="color:#333">==</span> NIL <span style="color:#333">&amp;&amp;</span> dfs_h(u)) {
                <span style="color:#333">++</span>m;
            }
        }
    }
    <span style="color:#080;font-weight:bold">return</span> m <span style="color:#333">==</span> n;
}

<span style="color:#339;font-weight:bold">bool</span> <span style="color:#06b;font-weight:bold">pfmatch</span>() { <span style="color:#080;font-weight:bold">return</span> hopcraft_karp(); }

<span style="color:#339;font-weight:bold">int</span> <span style="color:#06b;font-weight:bold">main</span>() {
    cin <span style="color:#333">&gt;&gt;</span> n;
    rep(i, n) { cin <span style="color:#333">&gt;&gt;</span> p[i].first <span style="color:#333">&gt;&gt;</span> p[i].second; }
    rep(i, n) { cin <span style="color:#333">&gt;&gt;</span> h[i].first <span style="color:#333">&gt;&gt;</span> h[i].second; }
    rep(i, n) {
        rep(j, n) {
            <span style="color:#339;font-weight:bold">int</span> idx <span style="color:#333">=</span> i <span style="color:#333">*</span> n <span style="color:#333">+</span> j;
            <span style="color:#339;font-weight:bold">int</span> dis <span style="color:#333">=</span> abs(p[i].X <span style="color:#333">-</span> h[j].X) <span style="color:#333">+</span> abs(p[i].Y <span style="color:#333">-</span> h[j].Y);
            d[idx] <span style="color:#333">=</span> {dis, {i, j}};
        }
    }
    sort(d, d <span style="color:#333">+</span> n <span style="color:#333">*</span> n);
    <span style="color:#339;font-weight:bold">int</span> l <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">0</span>, r <span style="color:#333">=</span> n <span style="color:#333">*</span> n <span style="color:#333">-</span> <span style="color:#00d;font-weight:bold">1</span>;
    <span style="color:#888">// binary search
</span><span style="color:#888"></span>    <span style="color:#888">// time complexity: O(n^3lgn) for hungarian,
</span><span style="color:#888"></span>    <span style="color:#888">// O(n^2√n * lgn) for hopcroft-karp
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">while</span> (l <span style="color:#333">&lt;</span> r <span style="color:#333">&amp;&amp;</span> d[l].first <span style="color:#333">!=</span> d[r].first) {
        <span style="color:#888">// replay
</span><span style="color:#888"></span>        rep(i, n) { edges[i].clear(); }
        <span style="color:#339;font-weight:bold">int</span> mid <span style="color:#333">=</span> (l <span style="color:#333">+</span> r) <span style="color:#333">/</span> <span style="color:#00d;font-weight:bold">2</span>;
        repe(i, mid) {
            <span style="color:#339;font-weight:bold">int</span> pi <span style="color:#333">=</span> d[i].second.first, hj <span style="color:#333">=</span> d[i].second.second;
            link(hj, pi);
        }
        <span style="color:#080;font-weight:bold">if</span> (pfmatch()) {
            r <span style="color:#333">=</span> mid;
        } <span style="color:#080;font-weight:bold">else</span> {
            l <span style="color:#333">=</span> mid <span style="color:#333">+</span> <span style="color:#00d;font-weight:bold">1</span>;
        }
    }
    cout <span style="color:#333">&lt;&lt;</span> d[l].first <span style="color:#333">&lt;&lt;</span> endl;
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">0</span>;
}
</code></pre></div>
      </div>
    </section>
    
    <section class="pagination clearfix">
      
      <a class="btn previous " href="https://blog.crazyark.xyz/posts/hourrank23/"> 稀疏表和并行二分查找 (Sparse Table &amp; Parallel Binary Search) </a> 
       
      
      <a class="btn next " href="https://blog.crazyark.xyz/posts/game_theory/"> 博弈论-公平组合游戏 (Game Theory -- Impartial Combinatorial Games) </a> 
      
    </section>
    
    
<section id="disqus_thread" class='disqus'></section>
<script>
  var disqus_config = function () {
    this.page.url = "https://blog.crazyark.xyz/posts/maximum_matching_in_bipartite_graph/";
    
  };
  (function() {
    var d = document, s = d.createElement('script');
    s.src = '//crazyark.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

  </div>
  
  <footer>
  <div class="footer-info">
    <p>
      <a href="mailto:arkbriar@gmail.com?subject="><i class="far fa-envelope"></i> arkbriar@gmail.com </a>
      {
        <a href="https://gohugo.io/" title="Hugo :: A fast and modern static website engine">Hugo 0.87.0</a>,
        <a href="https://github.com/IvanChou/yii.im" title="vec">Vec</a> 
      }
      {<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="CC BY-NC-ND 3.0">CC BY-NC-ND 3.0</a>}
    </p>
  </div>
</footer>


  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>

<style type="text/css" media="screen">
  code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    // Fix <code> tags after MathJax finishes running. This is a
    // hack to overcome a shortcoming of Markdown. Discussion at
    // https://github.com/mojombo/jekyll/issues/199
    var all = MathJax.Hub.getAllJax();
    all.forEach(function(e) {
        e.SourceElement().parentNode.className += ' has-jax';
    });
});
</script>

  
  <script src="https://blog.crazyark.xyz/js/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  

</body>

</html>
